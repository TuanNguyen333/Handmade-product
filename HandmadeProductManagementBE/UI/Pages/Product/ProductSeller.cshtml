@page
@model UI.Pages.Product.ProductSellerModel
@{
    ViewData["Title"] = "Product Seller List";
}
@Html.AntiForgeryToken()

<h1 class="text-3xl font-bold mb-4">Product List</h1>

<div class="search-filter">
    <form method="get" class="flex space-x-4 items-center">
        <input class="border border-gray-300 rounded-md p-2" type="text" name="Name" placeholder="Search by name" value="@Request.Query["Name"]" onchange="this.form.submit();" />
        <select name="CategoryId" class="border border-gray-300 rounded-md p-2">
            <option value="">Select Category</option>
            @if (Model.Categories != null && Model.Categories.Any())
            {
                foreach (var category in Model.Categories)
                {
                    var isSelected = Request.Query["CategoryId"] == category.Id.ToString();
                    if (isSelected)
                    {
                        <option value="@category.Id" selected>@category.Name</option>
                    }
                    else
                    {
                        <option value="@category.Id">@category.Name</option>
                    }
                }
            }
        </select>
        @{
            var selectedStatus = Request.Query["Status"].ToString();
        }

        <select name="Status" class="border border-gray-300 rounded-md p-2">
            @if (string.IsNullOrEmpty(selectedStatus))
            {
                <option value="" selected>Select Status</option>
            }
            else
            {
                <option value="">Select Status</option>
            }

            @if (selectedStatus == "Available")
            {
                <option value="Available" selected>Available</option>
            }
            else
            {
                <option value="Available">Available</option>
            }

            @if (selectedStatus == "OutOfStock")
            {
                <option value="OutOfStock" selected>Out Of Stock</option>
            }
            else
            {
                <option value="OutOfStock">Out Of Stock</option>
            }
        </select>
        <input class="border border-gray-300 rounded-md p-2" type="number" name="MinRating" placeholder="Min Rating" min="0" max="5" value="@Request.Query["MinRating"]" />

        <div class="flex items-center space-x-4">
            <label class="flex items-center">
                <input type="radio" id="sortByPrice" name="SortOption" value="SortByPrice"
                @(Request.Query["SortOption"] == "SortByPrice" ? "checked" : "") onchange="this.form.submit();" />
                <span class="ml-2">Sort by Price</span>
            </label>

            <label class="flex items-center">
                <input type="radio" id="sortByRating" name="SortOption" value="SortByRating"
                @(Request.Query["SortOption"] == "SortByRating" ? "checked" : "") onchange="this.form.submit();" />
                <span class="ml-2">Sort by Rating</span>
            </label>
        </div>



        <label class="flex items-center">
            <span class="mr-2">Sort Descending:</span>
            <input type="checkbox" name="sortDescending" value="true"
            @(Request.Query["SortDescending"] == "true" ? "checked" : "") onchange="this.form.submit();" />
        </label>

        <button type="submit" class="bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600">Search</button>
        <button type="button" onclick="openAddProductModal()"
                class="bg-green-500 text-white py-2 px-4 rounded-md hover:bg-green-600">
            Add Product
        </button>
    </form>
</div>

<!-- Product List -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 mt-8">
    @if (Model.Products != null && Model.Products.Any())
    {
        foreach (var product in Model.Products)
        {
            <div class="border rounded-lg shadow-md p-4">
                <div class="aspect-w-1 aspect-h-1 mb-4">
                    @if (!string.IsNullOrEmpty(product.ProductImageUrl))
                    {
                        <img src="@product.ProductImageUrl" alt="@product.Name" class="object-cover rounded-md w-full h-48" />
                    }
                    else
                    {
                        <div class="bg-gray-200 rounded-md w-full h-48 flex items-center justify-center">
                            <span class="text-gray-500">No image</span>
                        </div>
                    }
                </div>
                <h3 class="text-lg font-semibold">@product.Name</h3>
                @*                 <p class="text-gray-600 text-sm mb-2">@product.Category?.Name</p>
        *@                <p class="text-gray-800 font-medium">$@product.LowestPrice.ToString("F2")</p>
                <div class="flex items-center mt-2">
                    <span class="text-yellow-400">★</span>
                    <span class="ml-1">@product.Rating.ToString("F1")</span>
                    @*                     <span class="text-gray-500 ml-2">(@product.ReviewCount reviews)</span>
            *@
                </div>
                <div class="mt-3 flex justify-between items-center">
                    <div class="text-sm text-gray-500 mt-2">
                        <span id="status-label-@product.Id" class="px-2 py-1 rounded-full text-sm @(product.Status == "Available" ? "bg-green-100 text-green-800" : "bg-red-100 text-red-800")">@product.Status</span>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="toggleProductStatus('@product.Id', '@product.Status', this)"
                                class="@(product.Status == "Available" ? "bg-yellow-500 hover:bg-yellow-600 text-white py-1 px-3 rounded-md" : "bg-green-500 hover:bg-green-600 text-white py-1 px-3 rounded-md")">
                            @(product.Status == "Available" ? "Deactivate" : "Activate")
                        </button>
                        <button onclick="loadProductDetails('@product.Id')"
                                class="bg-blue-500 text-white py-1 px-3 rounded-md hover:bg-blue-600">
                            Edit
                        </button>
                        <button onclick="deleteProduct('@product.Id')"
                                class="bg-red-500 text-white py-1 px-3 rounded-md hover:bg-red-600">
                            Delete
                        </button>
                    </div>
                </div>
            </div>
        }
    }
    else
    {
        <div class="col-span-full text-center py-8">
            <p class="text-gray-500">No products found.</p>
        </div>
    }
</div>

@{
    var paginationModel = new UI.Pages.Shared.PaginationModel
            {
                PageNumber = Model.PageNumber,
                PageSize = Model.PageSize
            };
}

<partial name="~/Pages/Shared/_Pagination.cshtml" model="paginationModel" />

<!-- Add Product Modal -->
<div id="addProductModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-3/4 max-h-[90vh] overflow-y-auto">
        <h2 class="text-2xl font-bold mb-4 text-center">Add New Product</h2>

        <form asp-page-handler="CreateProduct" method="post" enctype="multipart/form-data" class="space-y-4">
            <!-- Basic Product Information -->
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Product Name</label>
                    <input type="text" asp-for="ProductCreation.Name" required
                           class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Category</label>
                    <select asp-for="ProductCreation.CategoryId"
                            asp-items="@(new SelectList(Model.Categories, "Id", "Name"))"
                            required
                            id="categorySelect"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                        <option value="">Select Category</option>
                    </select>
                </div>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700">Description</label>
                <textarea asp-for="ProductCreation.Description" rows="3"
                          class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></textarea>
            </div>

            <!-- Existing Variations Section -->
            <div id="existingVariationsContainer" class="border-t pt-4">
                <h3 class="text-lg font-medium mb-2">Existing Variations</h3>
                <div id="existingVariationsList"></div>
            </div>

            <!-- New Variations Section -->
            <div id="newVariationsContainer"></div>
            <button type="button" id="addNewVariationBtn" class="btn btn-secondary mb-4">
                Add New Variation
            </button>

            <!-- Update your variation combination section -->
            <div id="variationCombinationContainer" class="border-t pt-4">
                <h3 class="text-lg font-medium mb-2">Variation Combinations</h3>
            </div>

            <!-- Image Upload -->
            <div class="border-t pt-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Product Images</label>
                <input type="file" id="productImages" name="ProductImages" multiple accept="image/*"
                       onchange="previewImages(this)" class="hidden" />
                <button type="button" onclick="document.getElementById('productImages').click()"
                        class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">
                    Choose Images
                </button>
                <div id="imagePreviewContainer" class="grid grid-cols-4 gap-4 mt-4"></div>
            </div>

            <div class="flex justify-end space-x-4 pt-4 border-t">
                <button type="button" onclick="closeAddProductModal()"
                        class="bg-gray-500 text-white px-6 py-2 rounded-md hover:bg-gray-600">
                    Cancel
                </button>
                <button type="submit"
                        class="bg-blue-500 text-white px-6 py-2 rounded-md hover:bg-blue-600">
                    Create Product
                </button>
            </div>
        </form>
    </div>
</div>

<!-- Edit Product Modal -->
<div id="editProductModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center">
    <div class="bg-white p-6 rounded-lg w-3/4 max-h-[90vh] overflow-y-auto">
        <h2 class="text-2xl font-bold mb-4 text-center">Edit Product</h2>

        <form asp-page-handler="UpdateProduct" method="post" enctype="multipart/form-data" class="space-y-4">
            <input type="hidden" id="editProductId" name="ProductUpdate.Id" />

            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Product Name</label>
                    <input type="text" name="ProductUpdate.Name" id="editProductName" required
                           class="mt-1 block w-full rounded-md border-gray-300 shadow-sm" />
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Category</label>
                    <select name="ProductUpdate.CategoryId" id="editCategorySelect"
                            asp-items="@(new SelectList(Model.Categories, "Id", "Name"))"
                            required
                            onchange="loadProductVariations(this.value)"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm">
                        <option value="">Select Category</option>
                    </select>
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">Description</label>
                <textarea name="ProductUpdate.Description" id="editProductDescription" rows="3"
                          class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"></textarea>
            </div>
            <div id="editExistingVariationsContainer" class="border-t pt-4">
                <h3 class="text-lg font-medium text-gray-900 mb-4">Existing Variations</h3>
                <div id="editVariationsList" class="space-y-4">
                    <!-- Variations will be populated dynamically -->
                </div>
            </div>

            <!-- New Variations Section -->
            <div id="newVariationsContainerForEditing"></div>
            <button type="button" id="addNewVariationBtnForEditing" class="btn btn-secondary mb-4">
                Add New Variation
            </button>

            <!-- Update your variation combination section -->
            <div id="variationCombinationEditContainer" class="border-t pt-4">
                <h3 class="text-lg font-medium mb-2">Variation Combinations</h3>
                <div id="editProductCombination" class="grid grid-cols-2 gap-4 mb-4">
                    <!-- Variation combinations will be populated dynamically -->
                </div>
            </div>

            <!-- Image Section -->
            <div class="mb-4">
                <!-- Current Images Display -->
                <div>
                    <h3 class="text-lg font-semibold mb-2">Current Images</h3>
                    <div id="currentImagesContainer" class="grid grid-cols-4 gap-4 mb-4">
                        <!-- Current product images will be displayed here -->
                    </div>
                </div>

                <!-- New Image Upload -->
                <div class="border-t pt-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Add New Images</label>
                    <input type="file" id="productImages" name="ProductImages" multiple accept="image/*"
                           onchange="previewImagesForEditing(this)" class="hidden" />
                    <button type="button" onclick="document.getElementById('productImages').click()"
                            class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">
                        Choose Images
                    </button>
                    <div id="imagePreviewContainerForEditing" class="grid grid-cols-4 gap-4 mt-4">
                        <!-- Previews of new images will be displayed here -->
                    </div>
                </div>
            </div>

            <div class="flex justify-end space-x-3 pt-4">
                <button type="button" onclick="closeEditModal()"
                        class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md">
                    Cancel
                </button>
                <button type="submit"
                        class="px-4 py-2 text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 rounded-md">
                    Update Product
                </button>
            </div>
        </form>
    </div>
</div>

@section Scripts {
    <script>
        async function toggleProductStatus(productId, currentStatus, button) {
            try {
                const isAvailable = currentStatus === "Available" ? false : true;
                const response = await fetch(`?handler=ToggleProductStatus&productId=${productId}&isAvailable=${isAvailable}`, {
                    method: 'POST',
                    headers: {
                        '__RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Update the product status label and button text immediately
                    const statusLabel = document.getElementById(`status-label-${productId}`);
                    const newStatus = isAvailable ? "Available" : "Unavailable";
                    statusLabel.textContent = newStatus;

                    // Update the status label class for color change
                    if (isAvailable) {
                        statusLabel.classList.remove("bg-red-100", "text-red-800");
                        statusLabel.classList.add("bg-green-100", "text-green-800");
                    } else {
                        statusLabel.classList.remove("bg-green-100", "text-green-800");
                        statusLabel.classList.add("bg-red-100", "text-red-800");
                    }

                    // Update the button text and style
                    button.textContent = isAvailable ? "Deactivate" : "Activate";
                    button.className = isAvailable ? "bg-yellow-500 hover:bg-yellow-600 text-white py-1 px-3 rounded-md"
                        : "bg-green-500 hover:bg-green-600 text-white py-1 px-3 rounded-md";

                    // Update the button's currentStatus value for next toggle
                    button.setAttribute("onclick", `toggleProductStatus('${productId}', '${newStatus}', this)`);
                } else {
                    alert(data.error || 'Failed to update product status');
                }
            } catch (error) {
                console.error('Error details:', error);
                alert('An unexpected error occurred while updating the product status.');
            }
        }

        // Delete Product Function
        async function deleteProduct(productId) {
            if (!confirm('Are you sure you want to delete this product?')) {
                return;
            }

            try {
                const token = document.querySelector('input[name="__RequestVerificationToken"]').value;
                const response = await fetch(`?handler=DeleteProduct&id=${productId}`, {
                    method: 'POST',
                    headers: {
                        'RequestVerificationToken': token
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete product');
                }

                alert('Product deleted successfully!');
                window.location.reload();
            } catch (error) {
                console.error('Error:', error);
                alert('An error occurred while deleting the product');
            }
        }

        //Add Product
        // Global state management
        const state = {
            existingVariationsData: [],
            selectedVariations: [],
            variationCombinations: []
        };

        // Utility functions
        const generateCombinations = (variations) => {
            if (variations.length === 0) return [];
            if (variations.length === 1) return variations[0].map(v => [v]);

            const result = [];
            const combine = (current, rest) => {
                if (rest.length === 0) {
                    result.push(current);
                    return;
                }
                rest[0].forEach(item => {
                    combine([...current, item], rest.slice(1));
                });
            };

            combine([], variations);
            return result;
        };

        const saveNewVariation = async (variationRow) => {
            try {
                const nameInput = variationRow.querySelector('input[name*=".Name"]');
                const optionInputs = variationRow.querySelectorAll('input[name*=".Options"]');
                const variationName = nameInput.value.trim();
                const options = Array.from(optionInputs).map(input => input.value.trim()).filter(Boolean);

                if (!variationName || options.length === 0) {
                    alert('Please enter variation name and at least one option');
                    return;
                }

                const categoryId = document.getElementById('categorySelect').value;
                const response = await fetch(`?handler=CategoryVariations&categoryId=${categoryId}`);
                const existingVariations = await response.json();
                const existingVariation = existingVariations.find(v =>
                    v.name.toLowerCase() === variationName.toLowerCase()
                );

                let variationId;
                let optionIds = [];

                if (existingVariation) {
                    variationId = existingVariation.id;
                    for (const option of options) {
                        const optionData = {
                            value: option,
                            variationId: variationId
                        };

                        const createOptionResponse = await fetch('?handler=CreateVariationOption', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                            },
                            body: JSON.stringify(optionData)
                        });

                        if (!createOptionResponse.ok) {
                            throw new Error('Failed to create option');
                        }

                        const optionResult = await createOptionResponse.json();
                        if (optionResult.success) {
                            optionIds.push(optionResult.optionId);
                        }
                    }
                } else {
                    const variationData = {
                        name: variationName,
                        categoryId: categoryId,
                        options: options
                    };

                    const createResponse = await fetch('?handler=CreateVariation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                        },
                        body: JSON.stringify(variationData)
                    });

                    if (!createResponse.ok) {
                        throw new Error('Failed to create variation');
                    }

                    const result = await createResponse.json();
                    if (result.success) {
                        variationId = result.variationId;
                        optionIds = result.optionIds;
                    } else {
                        throw new Error(result.message);
                    }
                }

                appendVariationToList(variationId, variationName, options, optionIds);
                variationRow.remove();
                updateVariationCombinations();
                alert('Variation saved successfully!');
            } catch (error) {
                console.error('Error saving variation:', error);
                alert('Failed to save variation: ' + error.message);
            }
        };

        const appendVariationToList = (variationId, variationName, options, optionIds) => {
            const variationDiv = document.createElement('div');
            variationDiv.classList.add('p-4', 'border', 'rounded-md', 'bg-gray-50', 'mb-4');
            variationDiv.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <span class="font-medium">${variationName}</span>
                    <button type="button"
                            onclick="removeExistingVariation('${variationId}')"
                            class="text-red-600 hover:text-red-800">
                        Remove
                    </button>
                </div>
                <div class="mt-2">
                    <select name="SelectedVariations"
                            data-variation-id="${variationId}"
                            data-variation-name="${variationName}"
                            class="form-select w-full rounded-md border-gray-300"
                            onchange="handleExistingVariationSelection(this)">
                        <option value="">Select ${variationName}</option>
                        ${options.map((option, index) =>
                `<option value="${optionIds[index]}">${option}</option>`
            ).join('')}
                    </select>
                </div>
            `;

            document.getElementById('existingVariationsList').appendChild(variationDiv);
        };

        const addNewVariationUI = () => {
            const container = document.getElementById('newVariationsContainer');
            const variationIndex = container.children.length;

            const newRow = document.createElement('div');
            newRow.classList.add('variation-row', 'mb-4', 'p-4', 'border', 'rounded');
            newRow.innerHTML = `
                <div class="flex items-center mb-2">
                    <label class="block text-sm font-medium text-gray-700 mr-2">Variation Name:</label>
                    <input type="text"
                           name="NewVariations[${variationIndex}].Name"
                           class="flex-grow mr-2 form-input rounded"
                           placeholder="Enter variation name"
                           required />
                    <button type="button"
                            onclick="this.closest('.variation-row').remove()"
                            class="text-red-600 hover:text-red-800">
                        Remove
                    </button>
                </div>
                <div class="variation-options">
                    <div class="option-row mb-2">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Options:</label>
                        <div class="flex items-center">
                            <input type="text"
                                   name="NewVariations[${variationIndex}].Options"
                                   class="form-input rounded flex-grow mr-2"
                                   placeholder="Enter option value"
                                   required />
                            <button type="button"
                                    onclick="addVariationOption(this.closest('.option-row'))"
                                    class="bg-blue-500 text-white px-3 py-1 rounded-md hover:bg-blue-600">
                                Add Option
                            </button>
                        </div>
                    </div>
                </div>
                <div class="mt-4">
                    <button type="button"
                            onclick="saveNewVariation(this.closest('.variation-row'))"
                            class="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600">
                        Save Variation
                    </button>
                </div>
            `;

            container.appendChild(newRow);
        };

        const validateInput = {
            price: (value) => {
                const price = parseFloat(value);
                return !isNaN(price) && price > 0;
            },
            stock: (value) => {
                const stock = parseInt(value);
                return !isNaN(stock) && stock >= 0;
            }
        };

        // Variation handling functions
        const handleExistingVariationSelection = async (selectElement) => {
            try {
                const variationId = selectElement.getAttribute('data-variation-id');
                const variationName = selectElement.getAttribute('data-variation-name');
                const optionId = selectElement.value;
                const optionName = selectElement.options[selectElement.selectedIndex].text;

                // Update state
                const existingIndex = state.existingVariationsData.findIndex(v => v.variationId === variationId);
                if (existingIndex >= 0) {
                    if (optionId) {
                        state.existingVariationsData[existingIndex] = {
                            variationId,
                            variationName,
                            optionId,
                            optionName
                        };
                    } else {
                        state.existingVariationsData.splice(existingIndex, 1);
                    }
                } else if (optionId) {
                    state.existingVariationsData.push({
                        variationId,
                        variationName,
                        optionId,
                        optionName
                    });
                }

                // Find the form using multiple selectors
                const form = selectElement.closest('form') ||
                    document.querySelector('form') ||
                    document.querySelector('[asp-page-handler="CreateProduct"]');

                if (!form) {
                    console.warn('Form not found, creating hidden input in the select element\'s parent');
                    // If no form is found, add the hidden input to the select's parent container
                    const container = selectElement.closest('.p-4') || selectElement.parentElement;

                    const hiddenInput = container.querySelector(`input[name="variation_${variationId}"]`) ||
                        document.createElement('input');

                    if (optionId) {
                        hiddenInput.type = 'hidden';
                        hiddenInput.name = `variation_${variationId}`;
                        hiddenInput.value = optionId;
                        if (!hiddenInput.parentElement) {
                            container.appendChild(hiddenInput);
                        }
                    } else if (hiddenInput.parentElement) {
                        hiddenInput.remove();
                    }
                } else {
                    // If form is found, proceed with normal hidden input handling
                    const hiddenInput = form.querySelector(`input[name="variation_${variationId}"]`) ||
                        document.createElement('input');

                    if (optionId) {
                        hiddenInput.type = 'hidden';
                        hiddenInput.name = `variation_${variationId}`;
                        hiddenInput.value = optionId;
                        if (!hiddenInput.parentElement) {
                            form.appendChild(hiddenInput);
                        }
                    } else if (hiddenInput.parentElement) {
                        hiddenInput.remove();
                    }
                }

                updateVariationCombinations();
            } catch (error) {
                console.error('Error handling variation selection:', error);
                console.log('Select element:', selectElement);
                console.log('Current state:', state);
                alert('Error updating variation selection. Please try again.');
            }
        };

        const handleNewVariationInput = (input) => {
            try {
                const variationRow = input.closest('.variation-row');
                if (!variationRow) return;

                const nameInput = variationRow.querySelector('input[name*=".Name"]');
                const optionInputs = variationRow.querySelectorAll('input[name*=".Options"]');

                if (!nameInput || !optionInputs.length) return;

                if (nameInput.value) {
                    // Remove existing variation with same name
                    state.selectedVariations = state.selectedVariations.filter(
                        v => v.variationId !== `new_${nameInput.value}`
                    );

                    // Add new options
                    optionInputs.forEach(optionInput => {
                        if (optionInput.value) {
                            state.selectedVariations.push({
                                variationId: `new_${nameInput.value}`,
                                variationName: nameInput.value,
                                optionId: `new_${optionInput.value}`,
                                optionName: optionInput.value
                            });
                        }
                    });

                    updateVariationCombinations();
                }
            } catch (error) {
                console.error('Error handling new variation input:', error);
            }
        };

        const updateVariationCombinations = () => {
            try {
                const container = document.getElementById('variationCombinationContainer');
                if (!container) return;

                container.innerHTML = '<h3 class="text-lg font-medium mb-2">Variation Combinations</h3>';

                // Group variations by name
                const groupedVariations = new Map();

                // Group existing variations
                state.existingVariationsData.forEach(v => {
                    if (!groupedVariations.has(v.variationName)) {
                        groupedVariations.set(v.variationName, []);
                    }
                    groupedVariations.get(v.variationName).push(v);
                });

                // Group new variations
                state.selectedVariations.forEach(v => {
                    if (!groupedVariations.has(v.variationName)) {
                        groupedVariations.set(v.variationName, []);
                    }
                    groupedVariations.get(v.variationName).push(v);
                });

                // Convert to array format for combination generation
                const variationsArray = Array.from(groupedVariations.values());
                if (!variationsArray.length) return;

                // Generate combinations
                const combinations = generateCombinations(variationsArray);

                combinations.forEach((combination, index) => {
                    const combinationDiv = document.createElement('div');
                    combinationDiv.classList.add('mb-4', 'p-4', 'border', 'rounded-md');

                    const optionsText = combination.map(item =>
                        `${item.variationName}: ${item.optionName}`
                    ).join(', ');

                    const optionIds = combination.map(item =>
                        item.optionId
                    ).join(',');

                    combinationDiv.innerHTML = `
                                <div class="mb-2 font-medium">${optionsText}</div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700">Price</label>
                                        <input type="number"
                                               name="VariationCombinations[${index}].Price"
                                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                               required min="0" step="0.01" />
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700">Stock</label>
                                        <input type="number"
                                               name="VariationCombinations[${index}].Stock"
                                               class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                               required min="0" step="1" />
                                    </div>
                                </div>
                                <input type="hidden"
                                       name="VariationCombinations[${index}].OptionIds"
                                       value="${optionIds}" />
                            `;

                    container.appendChild(combinationDiv);
                });
            } catch (error) {
                console.error('Error updating variation combinations:', error);
            }
        };

        // Category and variation loading
        const loadExistingVariations = async () => {
            try {
                const categoryId = document.getElementById('categorySelect')?.value;
                const container = document.getElementById('existingVariationsList');

                if (!container) return;
                container.innerHTML = '';

                if (!categoryId) return;

                const response = await fetch(`?handler=CategoryVariations&categoryId=${categoryId}`);
                if (!response.ok) throw new Error('Failed to load variations');

                const variations = await response.json();

                variations.forEach(variation => {
                    const variationDiv = document.createElement('div');
                    variationDiv.classList.add('p-4', 'border', 'rounded-md', 'bg-gray-50', 'mb-4');

                    variationDiv.innerHTML = `
                                <div class="flex items-center justify-between mb-2">
                                    <span class="font-medium">${variation.name}</span>
                                    <button type="button"
                                            onclick="removeExistingVariation('${variation.id}')"
                                            class="text-red-600 hover:text-red-800">
                                        Remove
                                    </button>
                                </div>
                                <div class="mt-2">
                                    <select name="SelectedVariations"
                                            data-variation-id="${variation.id}"
                                            data-variation-name="${variation.name}"
                                            class="form-select w-full rounded-md border-gray-300"
                                            onchange="handleExistingVariationSelection(this)">
                                        <option value="">Select ${variation.name}</option>
                                    </select>
                                </div>
                            `;

                    container.appendChild(variationDiv);
                    loadVariationOptions(variation.id, variationDiv.querySelector('select'));
                });
            } catch (error) {
                console.error('Error loading variations:', error);
                alert('Failed to load existing variations');
            }
        };

        const loadVariationOptions = async (variationId, selectElement) => {
            try {
                const response = await fetch(`?handler=VariationOptions&variationId=${variationId}`);
                if (!response.ok) throw new Error('Failed to load variation options');

                const options = await response.json();
                const firstOption = selectElement.options[0];
                selectElement.innerHTML = '';
                selectElement.appendChild(firstOption);

                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.id;
                    optionElement.textContent = option.value;
                    selectElement.appendChild(optionElement);
                });
            } catch (error) {
                console.error('Error loading variation options:', error);
                alert('Failed to load variation options');
            }
        };

        // Initialize the page
        document.addEventListener('DOMContentLoaded', () => {
            window.addVariationOption = addVariationOption;
            window.handleExistingVariationSelection = handleExistingVariationSelection;
            window.removeExistingVariation = removeExistingVariation;
            window.saveNewVariation = saveNewVariation;

            const categorySelect = document.getElementById('categorySelect');
            if (categorySelect) {
                categorySelect.addEventListener('change', loadExistingVariations);
                if (categorySelect.value) {
                    loadExistingVariations();
                }
            }

            const addVariationBtn = document.getElementById('addNewVariationBtn');
            if (addVariationBtn) {
                addVariationBtn.addEventListener('click', addNewVariationUI);
            }

            const form = document.querySelector('form[asp-page-handler="CreateProduct"]');
            if (form) {
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    if (await validateForm()) {
                        submitForm(form);
                    }
                });
            }
        });
        
        // Form validation and submission
        const validateForm = async () => {
            const name = document.querySelector('input[asp-for="ProductCreation.Name"]')?.value;
            const category = document.querySelector('select[asp-for="ProductCreation.CategoryId"]')?.value;

            if (!name || !category) {
                alert('Please fill in all required fields (Name and Category)');
                return false;
            }

            const hasExistingVariations = state.existingVariationsData.length > 0;
            const hasNewVariations = state.selectedVariations.length > 0;

            if (!hasExistingVariations && !hasNewVariations) {
                alert('Please select at least one variation or create a new one');
                return false;
            }

            const combinations = document.querySelectorAll('#variationCombinationContainer > div');
            if (!combinations.length) {
                alert('Please create at least one variation combination');
                return false;
            }

            let isValid = true;
            combinations.forEach(combo => {
                const price = combo.querySelector('input[name*=".Price"]')?.value;
                const stock = combo.querySelector('input[name*=".Stock"]')?.value;

                if (!validateInput.price(price) || !validateInput.stock(stock)) {
                    isValid = false;
                }
            });

            if (!isValid) {
                alert('Please enter valid price and stock for all variation combinations');
                return false;
            }

            return true;
        };

        const submitForm = async (form) => {
            try {
                const formData = new FormData(form);
                const response = await fetch('?handler=CreateProduct', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                if (response.redirected) {
                    window.location.href = response.url;
                    return;
                }

                const result = await response.json();
                if (result.success) {
                    alert('Product created successfully!');
                    window.location.reload();
                } else {
                    alert(result.message || 'Failed to create product. Please try again.');
                }
            } catch (error) {
                console.error('Error submitting form:', error);
                alert('An error occurred while creating the product. Please try again.');
            }
        };

        // Additional helper functions (continued)
        function addVariationOption(button) {
            const optionValue = prompt('Enter option value:');
            if (!optionValue) return;

            const variationOptions = button.closest('.variation-row').querySelector('.variation-options');
            const optionRow = document.createElement('div');
            optionRow.className = 'option-row flex items-center gap-2';

            optionRow.innerHTML = `
                <label class="inline-flex items-center p-2 border rounded-md bg-white flex-grow">
                    <input type="checkbox"
                           class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50"
                           onchange="handleVariationOptionChange(this)"
                           value="${optionValue}" />
                    <span class="ml-2">${optionValue}</span>
                </label>
                <button type="button"
                        onclick="removeVariationOption(this)"
                        class="bg-red-500 text-white p-2 rounded-md hover:bg-red-600">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            `;

            variationOptions.appendChild(optionRow);
            updateVariationCombinations();
        }

        const removeExistingVariation = (variationId) => {
            try {
                // Remove from state
                state.existingVariationsData = state.existingVariationsData.filter(
                    v => v.variationId !== variationId
                );

                // Remove from DOM
                const variationElement = document.querySelector(`select[data-variation-id="${variationId}"]`)
                    ?.closest('.p-4');
                if (variationElement) {
                    variationElement.remove();
                }

                // Remove hidden input
                const hiddenInput = document.querySelector(`input[name="variation_${variationId}"]`);
                if (hiddenInput) {
                    hiddenInput.remove();
                }

                updateVariationCombinations();
            } catch (error) {
                console.error('Error removing variation:', error);
            }
        };

        function displayCurrentImages(images) {
            const container = document.getElementById('currentImagesContainer');
            if (!container) {
                console.error('Current images container not found');
                return;
            }

            // Clear existing images
            container.innerHTML = '';

            // Display each image
            images.forEach((image, index) => {
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'relative';

                const img = document.createElement('img');
                img.src = image.imageUrl; // Adjust this based on your image object structure
                img.alt = `Product Image ${index + 1}`;
                img.className = 'w-full h-32 object-cover rounded-md';

                // Delete button
                const deleteButton = document.createElement('button');
                deleteButton.className = 'absolute top-0 right-0 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center m-1';
                deleteButton.innerHTML = '×';
                deleteButton.onclick = () => removeImage(image.id); // Adjust based on your image object structure

                imageWrapper.appendChild(img);
                imageWrapper.appendChild(deleteButton);
                container.appendChild(imageWrapper);
            });
        }

        function removeImage(imageId) {
            if (confirm('Are you sure you want to remove this image?')) {
                // Add your image removal logic here
                console.log(`Removing image with ID: ${imageId}`);
            }
        }

        // Image preview functionality
        function previewImages(input) {
            const imagePreviewContainer = document.getElementById('imagePreviewContainer');
            imagePreviewContainer.innerHTML = '';

            if (input.files) {
                Array.from(input.files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const imgWrapper = document.createElement('div');
                        imgWrapper.classList.add('relative');
                        imgWrapper.innerHTML = `
                                        <img src="${e.target.result}" class="w-full h-32 object-cover rounded-md" />
                                        <button type="button" onclick="removeImage(this)"
                                                class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center">
                                            ✖
                                        </button>
                                    `;
                        imagePreviewContainer.appendChild(imgWrapper);
                    };
                    reader.readAsDataURL(file);
                });
            }
        }

        // Function to remove an image from preview
        function removeImage(button) {
            const imgWrapper = button.closest('div');
            const fileInput = document.getElementById('productImages');
            const files = Array.from(fileInput.files);

            // Remove the corresponding file from FileList
            const index = Array.from(imgWrapper.parentNode.children).indexOf(imgWrapper);
            files.splice(index, 1);

            // Update FileList
            const dataTransfer = new DataTransfer();
            files.forEach(file => dataTransfer.items.add(file));
            fileInput.files = dataTransfer.files;

            // Remove preview
            imgWrapper.remove();
        }

        // Modal functionality
        function openAddProductModal() {
            document.getElementById('addProductModal').classList.remove('hidden');
            document.getElementById('addProductModal').classList.add('flex');
        }

        function closeAddProductModal() {
            document.getElementById('addProductModal').classList.remove('flex');
            document.getElementById('addProductModal').classList.add('hidden');
        }

























        //Edit Product
        const editProductState = {
            existingVariationsData: [],
            selectedVariations: [],
            variationCombinations: [],
            currentImages: [],
            newImages: []
        };

        // async function editProduct(productId) {
        //     try {
        //         // Reset state
        //         editProductState.existingVariationsData = [];
        //         editProductState.selectedVariations = [];
        //         editProductState.variationCombinations = [];
        //         editProductState.currentImages = [];
        //         editProductState.newImages = [];

        //         // Get the anti-forgery token
        //         const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]').value;
        //         if (!antiForgeryToken) {
        //             throw new Error('Anti-forgery token not found');
        //         }

        //         // Load product details and images in parallel
        //         const [productResponse, imagesResponse] = await Promise.all([
        //             fetch(`?handler=ProductDetails&productId=${productId}`, {
        //                 method: 'GET',
        //                 headers: {
        //                     'RequestVerificationToken': antiForgeryToken,
        //                     'Accept': 'application/json'
        //                 }
        //             }),
        //             fetch(`?handler=ProductImages&productId=${productId}`, {
        //                 method: 'GET',
        //                 headers: {
        //                     'RequestVerificationToken': antiForgeryToken,
        //                     'Accept': 'application/json'
        //                 }
        //             })
        //         ]);

        //         if (!productResponse.ok || !imagesResponse.ok) {
        //             throw new Error('Failed to load product data');
        //         }

        //         const productData = await productResponse.json();
        //         const imagesData = await imagesResponse.json();

        //         // Populate form
        //         populateEditForm(productData.product);

        //         // Display images
        //         if (imagesData && Array.isArray(imagesData)) {
        //             editProductState.currentImages = imagesData;
        //             displayCurrentImagesForEditing(imagesData);
        //         }

        //         // Load variations if category ID exists
        //         if (productData.product.categoryId) {
        //             await loadProductVariations(productData.product.categoryId, productData.product.productItems || []);
        //         }

        //         // Show modal
        //         openEditProductModal();
        //     } catch (error) {
        //         console.error('Error details:', error);
        //         alert(`Failed to load product details: ${error.message}`);
        //     }
        // }

        async function loadCurrentImages(productId) {
            try {
                const response = await fetch(`?handler=ProductImages&productId=${productId}`);
                const images = await response.json();

                const currentImagesContainer = document.getElementById('currentImagesContainer');
                currentImagesContainer.innerHTML = ''; // Clear any existing content

                images.forEach((image, index) => {
                    const imgDiv = document.createElement('div');
                    imgDiv.classList.add('relative');

                    const img = document.createElement('img');
                    img.src = image.imageUrl; // Assuming the response contains an imageUrl property
                    img.alt = `Product Image ${index + 1}`;
                    img.classList.add('w-full', 'h-auto', 'object-cover', 'rounded');

                    imgDiv.appendChild(img);
                    currentImagesContainer.appendChild(imgDiv);
                });
            } catch (error) {
                console.error('Failed to load images:', error);
            }
        }

        function displayCurrentImagesForEditing(images) {
            const container = document.getElementById('currentImagesContainer');
            if (!container) return;

            container.innerHTML = '';

            images.forEach((image, index) => {
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'relative group border rounded-md p-2';

                const img = document.createElement('img');
                img.src = image.imageUrl; // Use the Firebase image URL directly
                img.alt = `Product Image ${index + 1}`;
                img.className = 'w-full h-32 object-cover rounded-md';

                const deleteButton = document.createElement('button');
                deleteButton.className = 'absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity';
                deleteButton.innerHTML = '×';
                deleteButton.onclick = () => deleteProductImage(image.id);

                imageWrapper.appendChild(img);
                imageWrapper.appendChild(deleteButton);
                container.appendChild(imageWrapper);
            });
        }

        function openEditProductModal() {
            const modal = document.getElementById('editProductModal');
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function closeEditModal() {
            const modal = document.getElementById('editProductModal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }

        function populateEditForm(product) {
            if (!product) return;

            const fields = {
                'editProductId': product.id,
                'editProductName': product.name,
                'editProductDescription': product.description,
                'editCategorySelect': product.categoryId
            };

            for (const [id, value] of Object.entries(fields)) {
                const element = document.getElementById(id);
                if (element) {
                    element.value = value || '';
                }
            }
        }

        async function loadProductDetails(productId) {
            try {
                const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]').value;
                if (!antiForgeryToken) {
                    throw new Error('Anti-forgery token not found');
                }

                const [productResponse, imagesResponse] = await Promise.all([
                    fetch(`?handler=ProductDetails&productId=${productId}`, {
                        method: 'GET',
                        headers: {
                            'RequestVerificationToken': antiForgeryToken,
                            'Accept': 'application/json'
                        }
                    }),
                    fetch(`?handler=ProductImages&productId=${productId}`, {
                        method: 'GET',
                        headers: {
                            'RequestVerificationToken': antiForgeryToken,
                            'Accept': 'application/json'
                        }
                    })
                ]);

                if (!productResponse.ok || !imagesResponse.ok) {
                    throw new Error('Failed to load product data');
                }

                const productData = await productResponse.json();
                const imagesData = await imagesResponse.json();

                // Store product data in state
                editProductState.currentImages = imagesData;
                editProductState.existingVariationsData = productData.variations || [];
                editProductState.selectedVariations = productData.product.productItems || [];

                // Populate form
                populateEditForm(productData.product);

                // Display images
                if (imagesData && Array.isArray(imagesData)) {
                    displayCurrentImagesForEditing(imagesData);
                }

                // Load variations with selected options
                if (productData.product && productData.product.categoryId) {
                    await loadProductVariations(productData.product.categoryId, productData.product.productItems || []);
                }

                // Show modal
                openEditProductModal();
            } catch (error) {
                console.error('Error details:', error);
                alert(`Failed to load product details: ${error.message}`);
            }
        }

        async function loadProductVariations(categoryId, productItems = []) {
            try {
                const response = await fetch(`?handler=CategoryVariations&categoryId=${categoryId}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const variations = await response.json();
                const container = document.getElementById('editVariationsList');
                if (!container) {
                    throw new Error('Variations container not found');
                }

                container.innerHTML = '';

                for (const variation of variations) {
                    const variationDiv = createVariationSelect(variation);
                    container.appendChild(variationDiv);

                    const selectElement = variationDiv.querySelector('select');

                    // Load options and set selected value
                    await loadVariationOptionsForEditing(variation.id, selectElement);

                    // Find and set the selected option from productItems
                    if (productItems && productItems.length > 0) {
                        const selectedConfig = productItems[0].configurations.find(
                            config => config.variationId === variation.id
                        );
                        if (selectedConfig) {
                            selectElement.value = selectedConfig.optionId;
                        }
                    }

                    // Add change event listener
                    selectElement.addEventListener('change', () => {
                        handleVariationSelection(selectElement);
                        updateVariationCombinationsForEditing();
                    });
                }
            } catch (error) {
                console.error('Error loading variations:', error);
                alert('Failed to load variations: ' + error.message);
            }
        }

        async function loadVariationOptionsForEditing(variationId, selectElement, productItems) {
            try {
                const response = await fetch(`?handler=VariationOptions&variationId=${variationId}`);
                if (!response.ok) throw new Error('Failed to load variation options');

                const options = await response.json();
                const firstOption = selectElement.options[0]; // Keep the placeholder option
                selectElement.innerHTML = '';
                selectElement.appendChild(firstOption);

                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.id;
                    optionElement.textContent = option.value;

                    // Check if the option is already selected in editProductState.existingVariationsData
                    const existingVariation = editProductState.existingVariationsData.find(
                        v => v.variationId === variationId && v.optionId === option.id
                    );
                    if (existingVariation) {
                        optionElement.selected = true;
                    }

                    selectElement.appendChild(optionElement);
                });
            } catch (error) {
                console.error('Error loading variation options:', error);
                alert('Failed to load variation options');
            }
        }

        function renderEditableVariationCombinations() {
            const combinationContainer = document.getElementById('editProductCombination');
            if (!combinationContainer) return;

            combinationContainer.innerHTML = '';

            // Generate variation combinations based on editProductState.existingVariationsData
            const variationCombinations = generateVariationCombinations(editProductState.existingVariationsData);

            variationCombinations.forEach((combination, index) => {
                const variationCombinationDiv = document.createElement('div');
                variationCombinationDiv.classList.add('p-4', 'border', 'rounded-md');

                let variationNames = '';
                for (const config of combination) {
                    variationNames += `${config.variationName}: ${config.optionName} | `;
                }
                variationNames = variationNames.slice(0, -3); // Remove the last " | "

                variationCombinationDiv.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <span class="font-medium">${variationNames}</span>
                        <div class="flex items-center space-x-2">
                            <div class="text-sm font-medium">
                                <input type="number" name="ProductItemUpdates[${index}].QuantityInStock" value="${combination[0].quantityInStock}" class="w-20 form-input rounded-md quantity-input" />
                            </div>
                            <div class="text-sm font-medium">
                                <input type="number" name="ProductItemUpdates[${index}].Price" value="${combination[0].price}" class="w-20 form-input rounded-md price-input" />
                            </div>
                        </div>
                    </div>
                `;

                combinationContainer.appendChild(variationCombinationDiv);
            });
        }

        function generateVariationCombinations(selectedVariations) {
            if (!selectedVariations || selectedVariations.length === 0) return [];

            const variations = selectedVariations.filter(v => v.optionId);
            if (variations.length === 0) return [];

            const combinations = [{ configurations: [] }];

            variations.forEach(variation => {
                const newCombinations = [];
                combinations.forEach(combo => {
                    newCombinations.push({
                        configurations: [
                            ...combo.configurations,
                            {
                                variationId: variation.variationId,
                                variationName: variation.variationName,
                                optionId: variation.optionId,
                                optionName: variation.optionName
                            }
                        ]
                    });
                });
                combinations.length = 0;
                combinations.push(...newCombinations);
            });

            return combinations;
        }

        function getUpdatedProductItems() {
            // Collect updated product items from the input fields
            const productItems = [];
            const quantityInputs = document.querySelectorAll('.quantity-input');
            const priceInputs = document.querySelectorAll('.price-input');

            quantityInputs.forEach((quantityInput, index) => {
                const priceInput = priceInputs[index];
                productItems.push({
                    quantityInStock: parseInt(quantityInput.value, 10),
                    price: parseFloat(priceInput.value)
                });
            });

            return productItems;
        }

        async function loadVariationOptionsForEditing(variationId, selectElement) {
            try {
                const response = await fetch(`?handler=VariationOptions&variationId=${variationId}`);
                if (!response.ok) throw new Error('Failed to load variation options');

                const options = await response.json();
                const firstOption = selectElement.options[0]; // Keep the placeholder option
                selectElement.innerHTML = '';
                selectElement.appendChild(firstOption);

                options.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.id;
                    optionElement.textContent = option.value;
                    selectElement.appendChild(optionElement);
                });
            } catch (error) {
                console.error('Error loading variation options:', error);
                alert('Failed to load variation options');
            }
        }

        function previewImagesForEditing(input) {
            const container = document.getElementById('imagePreviewContainerForEditing');
            if (!container || !input.files) return;

            editProductState.newImages = Array.from(input.files);
            container.innerHTML = '';

            editProductState.newImages.forEach((file, index) => {
                if (!file.type.startsWith('image/')) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    const imageWrapper = document.createElement('div');
                    imageWrapper.className = 'relative group border rounded-md p-2';

                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.className = 'w-full h-32 object-cover rounded-md';
                    img.alt = file.name;

                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'absolute top-2 right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity';
                    deleteButton.innerHTML = '×';
                    deleteButton.type = 'button';
                    deleteButton.onclick = () => removeNewImage(index, imageWrapper);

                    imageWrapper.appendChild(img);
                    imageWrapper.appendChild(deleteButton);
                    container.appendChild(imageWrapper);
                };

                reader.readAsDataURL(file);
            });
        }

        function removeCurrentImage(imageId, element) {
            if (confirm('Are you sure you want to remove this image?')) {
                editProductState.currentImages = editProductState.currentImages.filter(img => img.id !== imageId);
                element.remove();
            }
        }

        function removeNewImage(index, element) {
            editProductState.newImages = editProductState.newImages.filter((_, i) => i !== index);
            element.remove();
        }

        function createVariationSelect(variation) {
            const div = document.createElement('div');
            div.classList.add('p-4', 'border', 'rounded-md', 'bg-gray-50', 'mb-4');

            div.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <span class="font-medium">${variation.name}</span>
                </div>
                <div class="mt-2">
                    <select name="SelectedVariations"
                            data-variation-id="${variation.id}"
                            data-variation-name="${variation.name}"
                            class="form-select w-full rounded-md border-gray-300"
                            onchange="handleExistingVariationSelection(this)">
                        <option value="">Select ${variation.name}</option>
                    </select>
                </div>
            `;

            return div;
        }

        async function deleteProductImage(imageId) {
            if (!confirm('Are you sure you want to delete this image?')) return;

            try {
                const form = document.querySelector('#editProductModal form');
                const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]').value;

                const response = await fetch('?handler=DeleteImage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': antiForgeryToken
                    },
                    body: JSON.stringify({ imageId })
                });

                if (!response.ok) throw new Error('Failed to delete image');

                const result = await response.json();
                if (result.success) {
                    // Remove image from state and UI
                    editProductState.currentImages = editProductState.currentImages.filter(img => img.id !== imageId);
                    displayCurrentImagesForEditing(editProductState.currentImages);
                } else {
                    throw new Error('Failed to delete image');
                }
            } catch (error) {
                console.error('Error deleting image:', error);
                alert('Failed to delete image');
            }
        }

        // Add edit-specific functions for variation handling
        function handleVariationSelection(selectElement) {
            const variationId = selectElement.getAttribute('data-variation-id');
            const variationName = selectElement.getAttribute('data-variation-name');
            const optionId = selectElement.value;
            const optionName = selectElement.options[selectElement.selectedIndex].text;

            // Update selected variations in state
            const variationIndex = editProductState.selectedVariations.findIndex(
                v => v.variationId === variationId
            );

            if (variationIndex >= 0) {
                if (optionId) {
                    editProductState.selectedVariations[variationIndex].optionId = optionId;
                    editProductState.selectedVariations[variationIndex].optionName = optionName;
                } else {
                    editProductState.selectedVariations.splice(variationIndex, 1);
                }
            } else if (optionId) {
                editProductState.selectedVariations.push({
                    variationId,
                    variationName,
                    optionId,
                    optionName
                });
            }

            updateVariationCombinationsForEditing();
        }

        function updateVariationCombinationsForEditing() {
            const container = document.getElementById('editProductCombination');
            if (!container) return;

            container.innerHTML = '';

            // Generate all possible combinations
            const combinations = generateVariationCombinations(editProductState.selectedVariations);

            combinations.forEach((combination, index) => {
                const combinationDiv = document.createElement('div');
                combinationDiv.classList.add('p-4', 'border', 'rounded-md', 'mb-4');

                // Find existing product item data if it exists
                const existingItem = editProductState.selectedVariations.find(item =>
                    JSON.stringify(item.configurations) === JSON.stringify(combination.configurations)
                );

                const stock = existingItem?.quantityInStock || 0;
                const price = existingItem?.price || 0;

                combinationDiv.innerHTML = `
                    <div class="flex flex-col space-y-2">
                        <div class="font-medium">
                            ${combination.configurations.map(c =>
                    `${c.variationName}: ${c.optionName}`
                ).join(' | ')}
                        </div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Stock</label>
                                <input type="number"
                                       class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                       name="combinations[${index}].stock"
                                       value="${stock}"
                                       min="0" />
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Price</label>
                                <input type="number"
                                       class="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                       name="combinations[${index}].price"
                                       value="${price}"
                                       min="0" />
                            </div>
                        </div>
                    </div>
                `;

                container.appendChild(combinationDiv);
            });
        }

        // Form submission handler
        document.querySelector('#editProductModal form').addEventListener('submit', async function (e) {
            e.preventDefault();

            try {
                const formData = new FormData(this);

                // Add variation combinations
                const combinations = Array.from(document.querySelectorAll('#editProductCombination > div')).map((div, index) => {
                    const stock = div.querySelector('input[name$=".stock"]').value;
                    const price = div.querySelector('input[name$=".price"]').value;
                    return {
                        stock: parseInt(stock),
                        price: parseFloat(price),
                        configurations: editProductState.selectedVariations[index]?.configurations || []
                    };
                });

                formData.append('combinations', JSON.stringify(combinations));

                // Add new images
                editProductState.newImages.forEach(file => {
                    formData.append('NewProductImages', file);
                });

                const response = await fetch('?handler=UpdateProduct', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    alert('Product updated successfully');
                    closeEditModal();
                    location.reload();
                } else {
                    throw new Error(result.message || 'Failed to update product');
                }
            } catch (error) {
                console.error('Error updating product:', error);
                alert('An error occurred while updating the product: ' + error.message);
            }
        });

        // Initialize addNewVariationBtnForEditing click handler
        document.getElementById('addNewVariationBtnForEditing').addEventListener('click', addNewVariationUIForEditing);

        function addNewVariationUIForEditing() {
            const container = document.getElementById('newVariationsContainerForEditing');
            const variationIndex = container.children.length;

            const newRow = document.createElement('div');
            newRow.classList.add('variation-row', 'mb-4', 'p-4', 'border', 'rounded');
            newRow.innerHTML = `
                <div class="flex items-center mb-2">
                    <label class="block text-sm font-medium text-gray-700 mr-2">Variation Name:</label>
                    <input type="text"
                           name="NewVariations[${variationIndex}].Name"
                           class="flex-grow mr-2 form-input rounded"
                           placeholder="Enter variation name"
                           required />
                    <button type="button"
                            onclick="this.closest('.variation-row').remove()"
                            class="text-red-600 hover:text-red-800">
                        Remove
                    </button>
                </div>
                <div class="variation-options">
                    <div class="option-row mb-2">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Options:</label>
                        <div class="flex items-center">
                            <input type="text"
                                   name="NewVariations[${variationIndex}].Options"
                                   class="form-input rounded flex-grow mr-2"
                                   placeholder="Enter option value"
                                   required />
                            <button type="button"
                                    onclick="addVariationOptionForEditing(this)"
                                    class="bg-blue-500 text-white px-3 py-1 rounded-md hover:bg-blue-600">
                                Add Option
                            </button>
                        </div>
                    </div>
                </div>
                <div class="mt-4">
                    <button type="button"
                            onclick="saveNewVariationForEditing(this.closest('.variation-row'))"
                            class="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600">
                        Save Variation
                    </button>
                </div>
            `;

            container.appendChild(newRow);
        }

        function addVariationOptionForEditing(button) {
            const optionsContainer = button.closest('.variation-options');
            const variationIndex = button.closest('.variation-row').querySelector('input[name*=".Name"]').name.match(/\d+/)[0];
            const newOptionRow = document.createElement('div');
            newOptionRow.classList.add('option-row', 'mb-2');
            newOptionRow.innerHTML = `
                <div class="flex items-center">
                    <input type="text"
                           name="NewVariations[${variationIndex}].Options"
                           class="form-input rounded flex-grow mr-2"
                           placeholder="Enter option value"
                           required />
                    <button type="button"
                            onclick="this.closest('.option-row').remove()"
                            class="text-red-600 hover:text-red-800">
                        Remove
                    </button>
                </div>
            `;
            optionsContainer.appendChild(newOptionRow);
        }

        async function saveNewVariationForEditing(variationRow) {
            try {
                const nameInput = variationRow.querySelector('input[name*=".Name"]');
                const optionInputs = variationRow.querySelectorAll('input[name*=".Options"]');
                const variationName = nameInput.value.trim();
                const options = Array.from(optionInputs).map(input => input.value.trim()).filter(Boolean);

                if (!variationName || options.length === 0) {
                    alert('Please enter variation name and at least one option');
                    return;
                }

                const categoryId = document.getElementById('editCategorySelect').value;
                const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]').value;

                const response = await fetch(`?handler=CategoryVariations&categoryId=${categoryId}`);
                const existingVariations = await response.json();
                const existingVariation = existingVariations.find(v =>
                    v.name.toLowerCase() === variationName.toLowerCase()
                );

                let variationId;
                let optionIds = [];

                if (existingVariation) {
                    variationId = existingVariation.id;
                    for (const option of options) {
                        const optionData = {
                            value: option,
                            variationId: variationId
                        };

                        const createOptionResponse = await fetch('?handler=CreateVariationOption', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'RequestVerificationToken': antiForgeryToken
                            },
                            body: JSON.stringify(optionData)
                        });

                        if (!createOptionResponse.ok) {
                            throw new Error('Failed to create option');
                        }

                        const optionResult = await createOptionResponse.json();
                        if (optionResult.success) {
                            optionIds.push(optionResult.optionId);
                        }
                    }
                } else {
                    const variationData = {
                        name: variationName,
                        categoryId: categoryId,
                        options: options
                    };

                    const createResponse = await fetch('?handler=CreateVariation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'RequestVerificationToken': antiForgeryToken
                        },
                        body: JSON.stringify(variationData)
                    });

                    if (!createResponse.ok) {
                        throw new Error('Failed to create variation');
                    }

                    const result = await createResponse.json();
                    if (result.success) {
                        variationId = result.variationId;
                        optionIds = result.optionIds;
                    } else {
                        throw new Error(result.message);
                    }
                }

                // Refresh variations list
                await loadProductVariations(categoryId);

                // Remove the new variation UI
                variationRow.remove();

                alert('Variation saved successfully!');
            } catch (error) {
                console.error('Error saving variation:', error);
                alert('Failed to save variation: ' + error.message);
            }
        }

        async function deleteVariation(variationId) {
            if (!confirm('Are you sure you want to delete this variation?')) return;

            try {
                const antiForgeryToken = document.querySelector('input[name="__RequestVerificationToken"]').value;
                const response = await fetch(`?handler=DeleteVariation&variationId=${variationId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'RequestVerificationToken': antiForgeryToken
                    }
                });

                if (response.ok) {
                    // Remove the variation from the UI
                    const variationDiv = document.querySelector(`[data-variation-id="${variationId}"]`);
                    if (variationDiv) {
                        variationDiv.remove();
                    }

                    // Update the variation combinations
                    await loadProductVariations(document.getElementById('editCategorySelect').value);
                } else {
                    throw new Error('Failed to delete variation');
                }
            } catch (error) {
                console.error('Error deleting variation:', error);
                alert('Failed to delete variation');
            }
        }
    </script>
}